## Entity Framework
EF is Microsoft open source ORM (Object-Relational Mapper). It has some very nice features, it is a very good ORM.

## Table of contents
* [Model first approach](#model-first-approach)
* [Code first approach](#code-first-approach)

### Eager and lazy loading
**Lazy loading** - default, loading associated data only when referenced:
```csharp
var machine = context.Machines.FirstOrDefault(x => x.Id == 5).ToList(); //machine.Logs == null
var logs = machine.Logs; //exactly in this moment Logs are loaded
```

**Eager loading** - Logs are loaded toegether with Machines, thanks to **Include** method:
```csharp
var machine = context.Machines.Include(x => x.Logs).FirstOrDefault(x => x.Id == 5); 
```

**Explicit lazy loading** - available after turning off default lazy loading:
```csharp
context.Configuration.LazyLoadingEnabled = false; //turn off lazy loading
context.Entry(machine).Collection(x => x.Logs).Load();  //explicitly use lazy loading for Logs
var logs = machine.Logs; //load Logs
```

### Disconnected mode
Disconnected mode is used when you are dealing with objects without context (DBContext). It may occur when you get some object using some context, but you want to modify it when this context is disposed. To handle objects in disconnected mode, they must be attached to a new context and its state must be updated (**EntityState** - Unchanged, Added, Modified, Deleted, Detached). 
```csharp
Student student = null; 
using (var context = new SchoolDBEntities())
{
    context.Configuration.ProxyCreationEnabled = false;
    student = context.Students.FirstOrDefault(s => s.Id == 1);
}
student.Name = 'New student';

using (var context2 = new SchoolDBEntities())
{
    context2.Entry(student).State = EntityState.Modified;
    context2.SaveChanges();
}
```
When it comes to adding and deleting objects in disconnected mode, it is a bit easier because Add and Delete methods can automatically attach objects to context and update their state.

### Print out generated SQL query
Put the following line of code before the line that generates the query:
```csharp
context.Database.Log = Console.Write;
```

## Model first approach

### Create EF project
->File ->New ->Project ->Class Library (type of a new project)<br />
Add Entity Framework 6 package from NuGet to your project and decide what approach you want to use.<br /><br />
**DB First:**<br /> 
->Right click in the background of edmx diagram ->Update Model from Database...<br />
**Model First:**<br /> 
->Right click in the background of edmx diagram ->Generate Database from Model... ->...<br /> 
->Open edmx.sql file ->Execute

### New association in Model First
->Right click on some entity ->Add New ->Association ->Set options according to your needs and check the option: Add foreign key properties to the 'Entity1' Entity

### Add enum type
**Method 1** - add new enum type:<br />
->Right click in the background of edmx diagram ->Add new ->Enum Type...<br />
**Method 2** - convert field to enum:<br />
->Right click on a field of entity ->Convert to Enum...

### Common errors and exceptions
**Model class of name System** <br />
If you will add a new model class which will be called **System**, you will encounter problems because there will be name conflict between your class and .Net System namespace (System.DateTime, System.Data, etc). So take it into consideration while naming your classes.

**The type DbSet<> is defined in an assembly that is not referenced**<br />
EF is not referenced in this project! (Add it from NuGet)

**Invalid object name 'dbo.TableX'**<br />
Table exists in the model, but doesn't exist in the database.

**Concurency**<br />
->Add **RowVersion** column of **timestamp** type in the database<br />
->Update the model in Visual Studio<br />
->For the **RowVersion** field in Visual Studio, set the property **Concurency Mode = Fixed**<br />
->You must handle **DbUpdateConcurrencyException** exception for every update operation

### Use TVF in Linq
->Write your own Table Value Function ->Right click in the background of edmx diagram ->Select your TVF ->**Model Explorer** (You should find it next to Solution Explorer tab) ->Function Imports ->Right click on your TVF ->Edit ->Check **Function Import is composable** and **Returns a collection of: Entites** and select what type it should return.<br />
Now you should be able to use your TVF toegether with Linq statements:
```csharp
context.YourTableValuedFunction(10).OrderBy(x => x.Id);
```

### Add partial class
The model classes generated by EF in model or database first approach are **partial** classes, so it is easy to extend their set of properties or methods, all you have to is to create a new partial class with the same name as the one that is already generated in your model. Here is an example:
```csharp
// partial class generated by EF
public partial class Log
{
	public int Id { get; set; }
	public System.DateTime Date { get; set; }
	public int MachineId { get; set; }
	public string Message { get; set; }
    
	public virtual Machine Machine { get; set; }
}

// your own partial class, with additional property for Log class
public partial class Log
{
   public string FullMessage
   {
      get
      {
         return $"{Machine?.Name}:{Date.ToShortDateString()} {Message}";
      }
   }
}
```

## Code first approach
Code Frst approach allows you to first write your domain model classes and then create database schema according to those classes. EF brings you stuff as Data Annotations and Fluent API to be able to specify some details about how to generate tables and columns (not null, primary key etc). It also allows to update the DB structure without deleting tabeles (Migrations). Moreover, you can also specify some test data that will be put into the database after each creation - that's a quite useful feature. In general, Code First approach is worth taking into consideration while creating application domain.

### Basic domain structure
Here we can see two classes with **one-to-many** relationship. One *Machine* can have many *Logs*. So wht we have to do is to add **ICollection** of type *Log* in *Machine* class and a *Machine* property in *Log* class so that would be clear that it is one-to-many relationship.<br />
Moreover we have to define our own class that will inherit from **DBContext**. It must have two **DBSet** collections of *Machine* and *Log* types. And actually that's all, we can now use our model domain classes after configuring connection string.
```csharp
public class Log
{
	public int Id { get; set; }
	public string Message { get; set; }
	public DateTime Date { get; set; }
	public int MachineId { get; set; }
	public Machine Machine { get; set; }
}

public class Machine
{
	public int Id { get; set; }
  	public string Name { get; set; }
  	public MachineType? Type { get; set; }
  	public virtual ICollection<Log> Logs { get; set; }
}

public class ExampleContext : DbContext
{
	public ExampleContext() : base("name=Example"){}
	public DbSet<Log> Logs { get; set; }
	public DbSet<Machine> Machines { get; set; }
}
```

### Disable pluralized table names
Deafult table names generated by EF are pluralized, so for example the table generated for the *Log* class will be named *Logs*. If you don't like this convention you can turn it off with Fluent API by overriding **OnModelCreating** method of your context class, here is how to do this:
```csharp
protected override void OnModelCreating(DbModelBuilder modelBuilder)
{
	modelBuilder.Conventions.Remove<PluralizingTableNameConvention>();
}
```

### Data Annotations
Data Annotations serve to set a bit more details about how to map your class properties into database columns. For example you can define which properties cannot be null with **Required** attribute or what is the maximum size of string (or other type) with **MaxLength** attribute. We can also ignore some properties and not map them at all with **NotMapped** attribute, but if a property has only a getter or only a setter it won't be mapped anyway, even without the attribute. Table name and schema can also be defined as wella as columns type and order. See the example:
```csharp
[Table("LogMaster", SchemaName="admin")]
public class Log
{
	[Required]
	[MaxLength(256)]
	public string Message { get; set; }
	
	[Column("LogDate", Order=1, TypeName="smalldate")]
	public DateTime Date { get; set; }
	
	//[NotMapped] - we don't need this attribute 
	//because this property has only getter so it won't be mapped anyway
	public string FullMessage
	{
		get
		{
    			return $"{Machine?.Name}:{Date.ToShortDateString()} {Message}";
		}
	}
}
```

### Fluent API
Fluent API serves for the same goal as Data Annotations but allow to do much more! All the Fluent API stuff goes inside of the **OnModelCreating** method of context class. Here we seen an example where we change the name of a column that will be generated and its type:
```csharp
protected override void OnModelCreating(DbModelBuilder modelBuilder)
{
   modelBuilder.Entity<Log>()
      .Property(p => p.Date)
      .HasColumnName("LogDate")
      .HasColumnType("smalldatetime");
}
```
A nice thing you can achieve with **Fluent API** is to split your model class into two separate tables! Here is how to do this:
```csharp
protected override void OnModelCreating(DbModelBuilder modelBuilder)
{
   modelBuilder.Entity<Machine>()
      .Map(m =>
      {
         m.Properties(p => new { p.MachineId, p.MachineName});
         m.ToTable("Machine");
      })
     .Map(m => {
         m.Properties(p => new { p.MachineId, p.Type, p.SerialNumber, p.ProductionDate });
         m.ToTable("MachineDetail");
      });
}
```
Be careful, to later match the rows from two separate tables you should attach *MachineId* for both of them.

### Migrations
Migrations allow the database to be update according to the change made in model class code, without having to delete and recreate the tables (what of course means loosing data) or altering the structure by hand (which means loosing a lot of time).<br />
There are two main types of migrations: Automatic and Code-based. Automatic Migration is implicit and as the name suggests totally automatic. It is easy to use but very difficult to debug if some problems will occur. Code-based Migration allows you to have full control over your database structure, so it is really good to choose this type of migration, but if you expect your database to be allways up-to-date, not support multiple versions then Automatic Migration may serve you well. 

### Automatic Migration
To enable migrations follow the steps: ->Tools ->NuGet Package Manger ->Package Manager Console, and type the following command in the PM console:
```powershell
enable-migrations -ProjectName 'Example.Domain'
```
The **Configuration** class should be generated for you in **Migration** folder. Change its constructor so it looks like this:
```csharp
public Configuration()
{
	AutomaticMigrationsEnabled = true;
	AutomaticMigrationDataLossAllowed = true; //be careful with this one!
    ContextKey = "Example.Domain.ExampleContext";
}
```
Go to your context class and change its contructor to:
```csharp
public ExampleContext() 
	: base("name=Example")
{
   Database.SetInitializer
      (new MigrateDatabaseToLatestVersion
         <ExampleContext, Migrations.Configuration>("CodeFirst"));
}
```
Now you an change your model and it should be automatically updated.

### Code-based Migration
To use Code-based Migrations you must `enable-migrations` in Package Manager Console, but **AutomaticMigrationsEnabled** in **Configuration** class must be set to **false**. And just the same like in Automatic Migration you must put **Database.SetInitializer** call in your db context class constructor.<br />
Now you can change something in your model classes. Anything. After you make a change, run the following commands in Package Manager Console:
```powershell
add-migrations 'Migration name' -ProjectName 'Example.Domain'
update-database -verbose -ProjectName 'Example.Domain'
```
In case of some problems difficult to resolve try using the following commands:
```powershell
add-migration initial -ignoreChanges -ProjectName 'Example.Domain'
update-database -verbose -targetMigration:'Migration name' -ProjectName 'Example.Domain'
```

### Seed
In **Configuration** class that was added to enable migrations, there is a method called **Seed**, it allows us to put some code there that will be executed after migrations, for example adding some test data. It is quite useful, here is some examle:
```csharp
protected override void Seed(ExampleContext context)
{
   context.LogCategories.AddOrUpdate(new[] {
		new LogCategory { Id = 1, Name = "Application" },
		new LogCategory { Id = 2, Name = "System" },
		new LogCategory { Id = 3, Name = "Security" },
		new LogCategory { Id = 4, Name = "User" }
   });
}
```

### Concurency check
Use such configuration:
```csharp
[TimeStamp]
public byte[] RowVersion { get; set; }
```
for automatic concurency check.

### Unit Testing EF Core with NUnit
```csharp
using NUnit.Framework;
using Microsoft.EntityFrameworkCore;
using Microsoft.Data.Sqlite;
using System;
 
namespace Corp.Project..Tests.Core
{
   [TestFixture]
   public class InMemoryBaseTests<T> where T : DbContext, new()
   {
      //Microsoft.EntityFrameworkCore.Sqlite
      protected DbContextOptions<T> options;
      protected T context;
      protected SqliteConnection connection;
 
      [SetUp]
      public virtual void SetUp()
      {
         connection = new SqliteConnection("DataSource=:memory:");
         connection.Open();
 
         options = new DbContextOptionsBuilder<T>()
            .UseSqlite(connection)
            .Options;
 
         context = Activator.CreateInstance(typeof(T), new object[] { options }) as T;
         context.Database.EnsureCreated();
      }
 
      [TearDown]
      public virtual void TearDown()
      {
         connection.Close();
      }
   }
}
```
